# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Мазин И.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Работа с такой базой знаний, как родословная --- простой способ продемонстрировать преимущества Пролога в области работы с большими объёмами данных. 

В этой курсовой работе потребовались навыки работы с задачами поиска и обработки естественного языка, выработанные в ходе выполнения лабораторных работ.

Большая часть приобретенных знаний была получена при написании эссе. 

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: `parent(родитель, ребенок)`, `sex(человек, m/f)`.
 3. Реализовать предикат проверки/поиска двоюродного брата. 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве.
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

В качестве родословного дерева в формате GEDCOM была взята родословная европейской знати. Количество индивидуумов в ней --- 33591.

## Конвертация родословного дерева

Я решил использовать язык Пролог, чтобы, во-первых, применить на практике приобретенные в ходе выполнения ЛР навыки написания программ на этом ЯП, и, во-вторых, лично для себя оценить возможности и удобство применения Пролога при работе с реальными проектами. Конвертация производилась посредством DCG грамматик.

Основной деталью конвертации стало чтение родословный в оперативную память. Можно было бы реализовать конвертацию через считывание конкретной строки и работе с нею на лету для экономии памяти, но так мы либо теряем в скорости, либо получаем усложненный код и, что самое главное, выигрываем память без необходимости, так как вес родословной равен 10мб. Также мы бы потеряли возможность отдельно получать базы имён, полов и родственных связей. Эта возможность была удобной при разработке конвертёра.

Первым этапом конвертации родословного дерева в данные, пригодные для использования ЯП Пролог, стало получение из неё всех пар вида Идентификатор-Имя. Этот процесс осуществляли строки кода:

`ifindi(X) --> "0 @I", number(X), "@ INDI", [10].`

`namee(Name) --> "1 NAME ", list(Name), anything.`

`list([]) --> [10], !.`
   
`list([L|Ls]) --> [L], list(Ls).`

Метаправило `ifindi(X)` находит в списке строк файла родословной строку, содержащую идентификатор индивидуума. После того, как идентификатор была найден, предикат переходит в режим поиска строки, содержащей имя. Когда имя будет найдено, пара вида Идентификатор-Имя будут записаны в выходной файл `NameBase.txt`.

Второй этап --- получение соответствия Идентификатор-Пол, только на этот раз запись будет производиться в файл `Genders.pl` в виде предикатов ЯП Пролог. Алгоритм тот же, за той лишь разницей, что предикат получения после нахождения идентификатора будет переходить в режим поиска пола. 

`sexx(S) --> "1 SEX ", char(S), [10].`

Третий этап --- получение пар вида Родитель-Ребёнок в виде предикатов ЯП Пролог. Алгоритм сравним с предыдущими двумя: сначала идёт поиск строки с отцом семьи, далее --- строки с матерью семьи, после --- строк с детьми. Индивидуумы опять же записываются через идентификаторы в дереве.

`hus(X) --> "1 HUSB @I", number(X), "@", [10].`

`wif(X) --> "1 WIFE @I", number(X), "@", [10].`

`chi(X) --> "1 CHIL @I", number(X), "@", [10].`


Работа с полученными данными имеет вид: перевод строк с именами в индентификаторы --- фактическая работа с предикатами.

## Предикат поиска родственника

Суть предиката --- "Y это двоюродный брат X". Работа предиката `cousin(X, Y)` во многом зависит от порядка выполнения предикатов, описанных в нём, поэтому его реализация состоит из 3 описаний. Приводить все не имеет смысла, так как они отличаются только порядком. Приведу реализацию, которая срабатывает, когда в запросе первый аргумент это переменная, а второй --- нет. 

`cousin(X, Y) :- nonvar(Y)`

				, sex(Y, m) % проверка пола
    
				, phrase_from_file(liness(S), 'NameBase.txt') % чтение базы пар Индентификатор-Имя
    
				, getname(S, Num0, Y) % получение имени по идентификатору
    
				, pparent(Num0P, Num0) % вычисление родителя Y
    
				, Num0P \= 0 % проверка, что у Y родитель известен
    
				, pparent(NumGP, Num0P) % вычесление родителя родителя Y
    
				, NumGP \= 0 % проверка, что у родителя Y родитель известен
    
				, pparent(NumGP, NumP) % вычисление родителя X
    
				, pparent(NumP, Num)` % вычисление X
    
				, Num0 \= Num % проверка, что X не равно Y
    
				, getname(S, Num, X) % получение имени X
    
				.

Протокол работы:

`2 ?- cousin("Пелайо I /Астурийский/", X).`

    X = "Родриго /Вестготский/" .

`3 ?- cousin(X, "Пелайо I /Астурийский/").`

    X = "Родриго /Вестготский/" .

`4 ?- cousin("Родриго /Вестготский/", X).`

    X = "Пелайо I /Астурийский/" .

## Определение степени родства

Решение производилось при помощи поиска в ширину. Пространство состояний определяется переходами вниз и вверх по родословной от очередного индивидуума. На каждом шаге BFS продолжает каждый полученный путь на предыдущем шаге на единицу. Каждая полученная продолжением вершина проверяется на совпадение с искомой. Если совпадения не произошло, то поиск начинается с начала.

`solvebfs( Start, End, Solution) :-check([ [Start] ], Solution, End);`

    bfs( [ [Start] ], Solution, End).

`bfs( [ [X | Path] | Paths], Solution, End ) :-`

    (bagof( [X1, X | Path ],
    
    ( up(X, X1), \+ member( X1, [X | Path])),
 
      NewPaths1) ; NewPaths1=[]),
   
    (bagof( [X1, X | Path ],
 
    ( down(X, X1), \+ member( X1, [X | Path])),
 
      NewPaths2) ; NewPaths2=[]),
   
    append(NewPaths1, NewPaths2, NewPaths),
 
    length(NewPaths, Size), Size \= 0,
 
    append( Paths, NewPaths, Paths1), !,
 
    (check(NewPaths, Solution, End) ; bfs( Paths1, Solution, End)); bfs( Paths, Solution, End).
    
В итоге мы получаем путь от `End` до `Start`. Делаем реверс пути и ставим ему в соответствие строку, содержащую цепочку родства индивидуумов: идём вниз по дереву --- пишем в цепочку `mother`/`father`, иначе --- `child`. Также учитываем частные случаи цепочек.

`getres([X, Y | T], Prom, Res) :- pparent(X, Y)`
         
         , X \= Y
								 
         , ssex(X, G)
								 
         , ((G=m
								 
         , append(Prom, "father - ", Prom0)) ; (G=f), append(Prom, "mother - ", Prom0))
								 
         , getres([Y | T], Prom0, Res).
								 
`getres([X, Y | T], Prom, Res) :- pparent(Y, X)`
								 
         , X \= Y
								 
         , append(Prom, "child - ", Prom0)
								 
         , getres([Y | T], Prom0, Res).

`getres([L], "child - father - ", "sister - ") :- ssex(L, f).`

`getres([L], "child - mother - ", "sister - ") :- ssex(L, f).`

`getres([L], "child - father - ", "brother - ") :- ssex(L, m).`

`getres([L], "child - mother - ", "brother - ") :- ssex(L, m).`

`getres([_], Res, Res).`

Протокол работы:

`2 ?- relative("brother", "Фавилла /Кантабрийский/", X).`

    X = "Теодофред /Вестготский/" .

`3 ?- relative(X, "Фавилла /Кантабрийский/", "Теодофред /Вестготский/").`
    
    X = "brother" ;
    
    X = "child - father" ;
    
    X = "brother" ;
    
    X = "child - mother" .

## Естественно-языковый интерфейс

Естественно-языковой интерфейс осуществляется через предикат `request(Str, Ans)`, где `Str` --- запрос, `Ans` --- аргумент, через который выводится ответ на запрос. Запросы осуществляются в виде запросов "Who is `X` to `Y`?" и "Who is `X`'s `Y`?". В первом запросе `Y` это имя, во втором --- "father", "mother" и т.д..

Реализация:

`requestt(X, Y) --> "Who is ", listt(X), " to ", listt(Y), "?".`

`requestt(X, Y) --> "Who is ", listt(X), "'s ", listt(Y), "?".`

`request(Str, Ans) :- phrase(requestt(X, Y), Str)`
					 
      , makework(X, Y, Ans).
					 
`makework(X, "brother", Ans) :- relative("brother", X, Ans).`

`makework(X, "sister", Ans) :- relative("sister", X, Ans).`

`makework(X, "son", Ans) :- parent(X, Ans), sex(Ans, m).`

`makework(X, "daughter", Ans) :- parent(X, Ans), sex(Ans, f).`

`makework(X, "father", Ans) :- parent(Ans, X), sex(Ans, m).`

`makework(X, "mother", Ans) :- parent(Ans, X), sex(Ans, f).`

`makework(X, Y, Ans) :- relative(Ans, X, Y).`

Протокол работы:

`5 ?- request("Who is Теодофред /Вестготский/'s brother?", X).`
    
    X = "Фавилла /Кантабрийский/" .

`6 ?- request("Who is Теодофред /Вестготский/ to Фавилла /Кантабрийский/?", X).`
    
    X = "brother" .

## Выводы

Реализация такой большой в сравнении с лабораторными работами программы оказалась не такой уж и сложной. Ошибки при разработке были исключительно логическими, без различных переполнений переменных или нарушения порядка, которые присущи в моих программах на ЯП С++, что не может не радовать. С другой стороны отладка программы оказалась гораздо сложнее, при разработке на С++, однако это скорее проблема неочевидности интерфейса отладчика. Также, насколько я понял, чтобы отладить конкретный предикат, нужно добавлять в этот предикат предикат `trace`. Также оптимизация потребления памяти программой на Прологе достаточно трудоёмкая задача, так мы не можем ввести такие уловки, как, например, хранение двух значений в одной пременной при помощи битовой маски.

Моё субъективное мнение --- работа с базами знаний на ЯП Пролог удобна и относительно проста в своей реализации, однако контроль того, что происходит в программе по мере её выполнения на уровне "железа", неизбежно утрачивается в силу уровня абстракции Пролога. 
